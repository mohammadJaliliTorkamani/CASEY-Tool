[
  {
    "id": 120,
    "cve": "CVE-2024-23679",
    "description": "Enonic XP versions less than 7.7.4 are vulnerable to a session fixation issue. An remote and unauthenticated attacker can use prior sessions due to the lack of invalidating session attributes.\n\n",
    "vulnerability": {
      "file_level": [
        {
          "name": "modules/lib/lib-auth/src/main/java/com/enonic/xp/lib/auth/LoginHandler.java",
          "content": "package com.enonic.xp.lib.auth;\n\nimport java.util.Comparator;\nimport java.util.concurrent.Callable;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\nimport javax.servlet.http.HttpSession;\n\nimport com.enonic.xp.context.Context;\nimport com.enonic.xp.context.ContextBuilder;\nimport com.enonic.xp.portal.PortalRequest;\nimport com.enonic.xp.script.bean.BeanContext;\nimport com.enonic.xp.script.bean.ScriptBean;\nimport com.enonic.xp.security.IdProvider;\nimport com.enonic.xp.security.IdProviderKey;\nimport com.enonic.xp.security.IdProviders;\nimport com.enonic.xp.security.RoleKeys;\nimport com.enonic.xp.security.SecurityConstants;\nimport com.enonic.xp.security.SecurityService;\nimport com.enonic.xp.security.SystemConstants;\nimport com.enonic.xp.security.User;\nimport com.enonic.xp.security.auth.AuthenticationInfo;\nimport com.enonic.xp.security.auth.EmailPasswordAuthToken;\nimport com.enonic.xp.security.auth.UsernamePasswordAuthToken;\nimport com.enonic.xp.security.auth.VerifiedEmailAuthToken;\nimport com.enonic.xp.security.auth.VerifiedUsernameAuthToken;\nimport com.enonic.xp.session.Session;\n\npublic final class LoginHandler\n    implements ScriptBean\n{\n    private enum Scope\n    {\n        SESSION, REQUEST\n    }\n\n    private String user;\n\n    private String password;\n\n    private boolean skipAuth;\n\n    private String[] idProvider;\n\n    private Integer sessionTimeout;\n\n    private Scope scope;\n\n    private Supplier<SecurityService> securityService;\n\n    private Supplier<Context> context;\n\n    private Supplier<PortalRequest> portalRequestSupplier;\n\n    public void setUser( final String user )\n    {\n        this.user = user;\n    }\n\n    public void setPassword( final String password )\n    {\n        this.password = password;\n    }\n\n    public void setSkipAuth( final boolean skipAuth )\n    {\n        this.skipAuth = skipAuth;\n    }\n\n    public void setIdProvider( final String[] idProvider )\n    {\n        this.idProvider = idProvider;\n    }\n\n    public void setSessionTimeout( final Integer sessionTimeout )\n    {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    public void setScope( final String scope )\n    {\n        this.scope = Scope.valueOf( scope );\n    }\n\n    public LoginResultMapper login()\n    {\n        AuthenticationInfo authInfo = noIdProviderSpecified() ? attemptLoginWithAllExistingIdProviders() : attemptLogin();\n\n        if ( authInfo.isAuthenticated() )\n        {\n            switch ( this.scope )\n            {\n                case REQUEST:\n                    this.context.get().getLocalScope().setAttribute( authInfo );\n                    break;\n                case SESSION:\n                default:\n                    createSession( authInfo );\n                    break;\n            }\n\n            return new LoginResultMapper( authInfo );\n        }\n        else\n        {\n            return new LoginResultMapper( authInfo, \"Access Denied\" );\n        }\n    }\n\n    private void createSession( final AuthenticationInfo authInfo )\n    {\n        final Session session = this.context.get().getLocalScope().getSession();\n        if ( session != null )\n        {\n            session.setAttribute( authInfo );\n        }\n\n        if ( this.sessionTimeout != null )\n        {\n            setSessionTimeout();\n        }\n    }\n\n    private boolean noIdProviderSpecified()\n    {\n        return this.idProvider == null || this.idProvider.length == 0;\n    }\n\n    private AuthenticationInfo attemptLoginWithAllExistingIdProviders()\n    {\n        final IdProviders idProviders = runAsAuthenticated( this::getSortedIdProviders );\n\n        for ( IdProvider idProvider : idProviders )\n        {\n            final AuthenticationInfo authInfo = authenticate( idProvider.getKey() );\n            if ( ( authInfo != null ) && authInfo.isAuthenticated() )\n            {\n                return authInfo;\n            }\n        }\n\n        return AuthenticationInfo.unAuthenticated();\n    }\n\n    private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from( idProviders.stream().\n            sorted( Comparator.comparing( u -> u.getKey().toString() ) ).\n            collect( Collectors.toList() ) );\n    }\n\n    private AuthenticationInfo attemptLogin()\n    {\n\n        for ( String uStore : idProvider )\n        {\n            final AuthenticationInfo authInfo = authenticate( IdProviderKey.from( uStore ) );\n            if ( ( authInfo != null ) && authInfo.isAuthenticated() )\n            {\n                return authInfo;\n            }\n        }\n\n        return AuthenticationInfo.unAuthenticated();\n    }\n\n    private AuthenticationInfo authenticate( IdProviderKey idProvider )\n    {\n        AuthenticationInfo authInfo = null;\n\n        if ( isValidEmail( this.user ) )\n        {\n            if ( this.skipAuth )\n            {\n                final VerifiedEmailAuthToken verifiedEmailAuthToken = new VerifiedEmailAuthToken();\n                verifiedEmailAuthToken.setEmail( this.user );\n                verifiedEmailAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( verifiedEmailAuthToken ) );\n            }\n            else\n            {\n                final EmailPasswordAuthToken emailAuthToken = new EmailPasswordAuthToken();\n                emailAuthToken.setEmail( this.user );\n                emailAuthToken.setPassword( this.password );\n                emailAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( emailAuthToken ) );\n            }\n        }\n\n        if ( authInfo == null || !authInfo.isAuthenticated() )\n        {\n            if ( this.skipAuth )\n            {\n                final VerifiedUsernameAuthToken usernameAuthToken = new VerifiedUsernameAuthToken();\n                usernameAuthToken.setUsername( this.user );\n                usernameAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( usernameAuthToken ) );\n            }\n            else\n            {\n                final UsernamePasswordAuthToken usernameAuthToken = new UsernamePasswordAuthToken();\n                usernameAuthToken.setUsername( this.user );\n                usernameAuthToken.setPassword( this.password );\n                usernameAuthToken.setIdProvider( idProvider );\n\n                authInfo = runAsAuthenticated( () -> this.securityService.get().authenticate( usernameAuthToken ) );\n            }\n        }\n\n        return authInfo;\n    }\n\n    private <T> T runAsAuthenticated( Callable<T> runnable )\n    {\n        final AuthenticationInfo authInfo = AuthenticationInfo.create().principals( RoleKeys.AUTHENTICATED ).user( User.ANONYMOUS ).build();\n        return ContextBuilder.from( this.context.get() ).\n            authInfo( authInfo ).\n            repositoryId( SystemConstants.SYSTEM_REPO_ID ).\n            branch( SecurityConstants.BRANCH_SECURITY ).build().\n            callWith( runnable );\n    }\n\n    private boolean isValidEmail( final String value )\n    {\n        return value != null && value.chars().filter( ch -> ch == '@' ).count() == 1;\n    }\n\n    private void setSessionTimeout()\n    {\n        final PortalRequest portalRequest = this.portalRequestSupplier.get();\n        if ( portalRequest != null )\n        {\n            final HttpSession httpSession = portalRequest.getRawRequest().getSession();\n            if ( httpSession != null )\n            {\n                httpSession.setMaxInactiveInterval( this.sessionTimeout );\n            }\n        }\n    }\n\n    @Override\n    public void initialize( final BeanContext context )\n    {\n        this.securityService = context.getService( SecurityService.class );\n        this.context = context.getBinding( Context.class );\n        this.portalRequestSupplier = context.getBinding( PortalRequest.class );\n    }\n}\n"
        }
      ],
      "method_level": [
        "private void createSession( final AuthenticationInfo authInfo )\n    {\n        final Session session = this.context.get().getLocalScope().getSession();\n        if ( session != null )\n        {\n            session.setAttribute( authInfo );\n        }\n\n        if ( this.sessionTimeout != null )\n        {\n            setSessionTimeout();\n        }\n    }",
        "private IdProviders getSortedIdProviders()\n    {\n        IdProviders idProviders = securityService.get().getIdProviders();\n        return IdProviders.from( idProviders.stream().\n            sorted( Comparator.comparing( u -> u.getKey().toString() ) ).\n            collect( Collectors.toList() ) );\n    }",
        "private <T> T runAsAuthenticated( Callable<T> runnable )\n    {\n        final AuthenticationInfo authInfo = AuthenticationInfo.create().principals( RoleKeys.AUTHENTICATED ).user( User.ANONYMOUS ).build();\n        return ContextBuilder.from( this.context.get() ).\n            authInfo( authInfo ).\n            repositoryId( SystemConstants.SYSTEM_REPO_ID ).\n            branch( SecurityConstants.BRANCH_SECURITY ).build().\n            callWith( runnable );\n    }"
      ],
      "hunk_level": [
        {
          "line_no": 113,
          "content": "        final Session session = this.context.get().getLocalScope().getSession();"
        },
        {
          "line_no": 116,
          "content": "            session.setAttribute( authInfo );"
        },
        {
          "line_no": 117,
          "content": "        }"
        },
        {
          "line_no": 119,
          "content": "        if ( this.sessionTimeout != null )"
        },
        {
          "line_no": 120,
          "content": "        {"
        },
        {
          "line_no": 121,
          "content": "            setSessionTimeout();"
        },
        {
          "line_no": 149,
          "content": "        return IdProviders.from( idProviders.stream()."
        },
        {
          "line_no": 150,
          "content": "            sorted( Comparator.comparing( u -> u.getKey().toString() ) )."
        },
        {
          "line_no": 151,
          "content": "            collect( Collectors.toList() ) );"
        },
        {
          "line_no": 221,
          "content": "        return ContextBuilder.from( this.context.get() )."
        },
        {
          "line_no": 222,
          "content": "            authInfo( authInfo )."
        },
        {
          "line_no": 223,
          "content": "            repositoryId( SystemConstants.SYSTEM_REPO_ID )."
        },
        {
          "line_no": 224,
          "content": "            branch( SecurityConstants.BRANCH_SECURITY ).build()."
        },
        {
          "line_no": 225,
          "content": "            callWith( runnable );"
        }
      ]
    },
    "cwe": [
      "CWE-384"
    ],
    "severity": "CRITICAL",
    "cvss_score": 9.8,
    "cvss_version": 3.1
  },
  {
    "id": 1035,
    "cve": "CVE-2024-41953",
    "description": "Zitadel is an open source identity management system. ZITADEL uses HTML for emails and renders certain information such as usernames dynamically. That information can be entered by users or administrators. Due to a missing output sanitization, these emails could include malicious code. This may potentially lead to a threat where an attacker, without privileges, could send out altered notifications that are part of the registration processes. An attacker could create a malicious link, where the injected code would be rendered as part of the email. On the user's detail page, the username was also not sanitized and would also render HTML, giving an attacker the same vulnerability. While it was possible to inject HTML including javascript, the execution of such scripts would be prevented by most email clients and the Content Security Policy in Console UI. This vulnerability is fixed in 2.58.1, 2.57.1, 2.56.2, 2.55.5, 2.54.8 2.53.9, and 2.52.3.",
    "vulnerability": {
      "file_level": [
        {
          "name": "internal/notification/templates/templateData.go",
          "content": "package templates\n\nimport (\n\t\"fmt\"\n\t\"html\"\n\n\t\"github.com/zitadel/zitadel/internal/domain\"\n\t\"github.com/zitadel/zitadel/internal/i18n\"\n)\n\nconst (\n\tDefaultFontFamily      = \"-apple-system, BlinkMacSystemFont, Segoe UI, Lato, Arial, Helvetica, sans-serif\"\n\tDefaultFontColor       = \"#22292f\"\n\tDefaultBackgroundColor = \"#fafafa\"\n\tDefaultPrimaryColor    = \"#5282C1\"\n)\n\ntype TemplateData struct {\n\tTitle           string\n\tPreHeader       string\n\tSubject         string\n\tGreeting        string\n\tText            string\n\tURL             string\n\tButtonText      string\n\tPrimaryColor    string\n\tBackgroundColor string\n\tFontColor       string\n\tLogoURL         string\n\tFontURL         string\n\tFontFaceFamily  string\n\tFontFamily      string\n\n\tIncludeFooter bool\n\tFooterText    string\n}\n\nfunc (data *TemplateData) Translate(translator *i18n.Translator, msgType string, args map[string]interface{}, langs ...string) {\n\tdata.Title = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageTitle), args, langs...)\n\tdata.PreHeader = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessagePreHeader), args, langs...)\n\tdata.Subject = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageSubject), args, langs...)\n\tdata.Greeting = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageGreeting), args, langs...)\n\tdata.Text = html.UnescapeString(translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageText), args, langs...))\n\tdata.ButtonText = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageButtonText), args, langs...)\n\t// Footer text is neither included in i18n files nor defaults.yaml\n\tfooterText := fmt.Sprintf(\"%s.%s\", msgType, domain.MessageFooterText)\n\tdata.FooterText = translator.Localize(footerText, args, langs...)\n\t// translator returns the id of the string to be translated if no translation is found for that id\n\t// we'll include the footer if we have a custom non-empty string and if the string doesn't include the\n\t// id of the string that could not be translated example InitCode.Footer\n\tdata.IncludeFooter = len(data.FooterText) > 0 && data.FooterText != footerText\n}\n"
        }
      ],
      "method_level": [
        "func (data *TemplateData) Translate(translator *i18n.Translator, msgType string, args map[string]interface{}, langs ...string) {\n\tdata.Title = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageTitle), args, langs...)\n\tdata.PreHeader = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessagePreHeader), args, langs...)\n\tdata.Subject = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageSubject), args, langs...)\n\tdata.Greeting = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageGreeting), args, langs...)\n\tdata.Text = html.UnescapeString(translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageText), args, langs...))\n\tdata.ButtonText = translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageButtonText), args, langs...)\n\t// Footer text is neither included in i18n files nor defaults.yaml\n\tfooterText := fmt.Sprintf(\"%s.%s\", msgType, domain.MessageFooterText)\n\tdata.FooterText = translator.Localize(footerText, args, langs...)\n\t// translator returns the id of the string to be translated if no translation is found for that id\n\t// we'll include the footer if we have a custom non-empty string and if the string doesn't include the\n\t// id of the string that could not be translated example InitCode.Footer\n\tdata.IncludeFooter = len(data.FooterText) > 0 && data.FooterText != footerText\n}"
      ],
      "hunk_level": [
        {
          "line_no": 43,
          "content": "\tdata.Text = html.UnescapeString(translator.Localize(fmt.Sprintf(\"%s.%s\", msgType, domain.MessageText), args, langs...))"
        }
      ]
    },
    "cwe": [
      "CWE-79"
    ],
    "severity": "MEDIUM",
    "cvss_score": 4.3,
    "cvss_version": 3.1
  },
  {
    "id": 29,
    "cve": "CVE-2024-21642",
    "description": "D-Tale is a visualizer for Pandas data structures. Users hosting versions D-Tale prior to 3.9.0 publicly can be vulnerable to server-side request forgery (SSRF), allowing attackers to access files on the server. Users should upgrade to version 3.9.0, where the `Load From the Web` input is turned off by default. The only workaround for versions earlier than 3.9.0 is to only host D-Tale to trusted users.",
    "vulnerability": {
      "file_level": [
        {
          "name": "dtale/datasets.py",
          "content": "import pandas as pd\nimport requests\nimport zipfile\n\nfrom six import BytesIO\n\n\ndef covid():\n    from dtale.cli.loaders.csv_loader import loader_func as load_csv\n\n    data = load_csv(\n        path=\"https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-states.csv\",\n        parse_dates=[\"date\"],\n    )\n    codes = load_csv(\n        path=\"https://raw.githubusercontent.com/jasonong/List-of-US-States/master/states.csv\"\n    )\n    codes = codes.set_index(\"State\").to_dict()[\"Abbreviation\"]\n    data[\"state_code\"] = data[\"state\"].map(codes)\n    return data, None\n\n\ndef seinfeld():\n    from dtale.cli.loaders.csv_loader import loader_func as load_csv\n\n    episodes = load_csv(\n        path=\"https://github.com/4m4n5/the-seinfeld-chronicles/raw/master/episode_info.csv\"\n    )\n    episodes = episodes[[c for c in episodes.columns if c not in [\"Unnamed: 0\"]]]\n    scripts = load_csv(\n        path=\"https://github.com/4m4n5/the-seinfeld-chronicles/raw/master/scripts.csv\"\n    )\n    scripts = scripts[\n        [c for c in scripts.columns if c not in [\"Unnamed: 0\", \"Season\", \"EpisodeNo\"]]\n    ]\n    return pd.merge(episodes, scripts, how=\"inner\", on=\"SEID\"), None\n\n\ndef load_zip(url):\n    response = requests.get(url)\n    with zipfile.ZipFile(BytesIO(response.content)) as thezip:\n        for zipinfo in thezip.infolist():\n            yield zipinfo.filename, thezip.open(zipinfo.filename)\n\n\ndef simpsons():\n    from dtale.cli.loaders.csv_loader import loader_func as load_csv\n    import dtale.global_state as global_state\n\n    global_state.set_app_settings(dict(max_column_width=100, max_row_height=100))\n    episodes = load_csv(\n        path=\"https://github.com/aschonfeld/dtale-media/raw/master/datasets/simpsons_episodes.csv\"\n    )\n    episodes = episodes.rename(columns={\"id\": \"episode_id\"})\n    episodes.loc[:, \"image_url\"] = episodes[\"image_url\"].apply(\n        lambda x: \"<img src='{}' style='height: auto; width: 100px;' />\".format(x)\n    )\n    _, scripts = next(\n        load_zip(\n            \"https://github.com/aschonfeld/dtale-media/raw/master/datasets/simpsons_script_lines.csv.zip\"\n        )\n    )\n    scripts = pd.read_csv(scripts)\n    df = pd.merge(episodes, scripts, how=\"inner\", on=\"episode_id\")\n    formatting = {\"image_url\": {\"fmt\": {\"html\": True}}}\n    return df, {\"columnFormats\": formatting}\n\n\ndef video_games():\n    _, games = next(\n        load_zip(\n            \"https://github.com/aschonfeld/dtale-media/raw/master/datasets/vgsales.csv.zip\"\n        )\n    )\n    return pd.read_csv(games), None\n\n\ndef movies():\n    _, movies = next(\n        load_zip(\n            \"https://github.com/aschonfeld/dtale-media/raw/master/datasets/IMDb_movies.csv.zip\"\n        )\n    )\n    movies = pd.read_csv(movies)\n    movies.loc[:, \"year\"] = (\n        movies[\"year\"].where(~(movies[\"year\"] == \"TV Movie 2019\"), \"2019\").astype(\"int\")\n    )\n    return movies, None\n\n\ndef time_dataframe():\n    try:\n        from pandas._testing import makeTimeDataFrame\n\n        return makeTimeDataFrame(), None\n    except ImportError:\n        from pandas.util.testing import makeTimeDataFrame\n\n        return makeTimeDataFrame(), None\n"
        }
      ],
      "method_level": [
        "def time_dataframe():\n    try:\n        from pandas._testing import makeTimeDataFrame\n\n        return makeTimeDataFrame(), None\n    except ImportError:\n        from pandas.util.testing import makeTimeDataFrame\n\n        return makeTimeDataFrame(), None"
      ],
      "hunk_level": [
        {
          "line_no": 92,
          "content": "    try:"
        },
        {
          "line_no": 93,
          "content": "        from pandas._testing import makeTimeDataFrame"
        },
        {
          "line_no": 95,
          "content": "        return makeTimeDataFrame(), None"
        },
        {
          "line_no": 96,
          "content": "    except ImportError:"
        },
        {
          "line_no": 97,
          "content": "        from pandas.util.testing import makeTimeDataFrame"
        },
        {
          "line_no": 99,
          "content": "        return makeTimeDataFrame(), None"
        }
      ]
    },
    "cwe": [
      "CWE-918"
    ],
    "severity": "HIGH",
    "cvss_score": 7.5,
    "cvss_version": 3.1
  }
]